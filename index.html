<html>
<body>
	<script type="text/javascript" src="js/jquery/jquery-2.0.3.js"></script>
	<script type="text/javascript" src="js/setImmediate/setImmediate.js"></script>
	<script type="text/javascript" src="js/monad/monad.js"></script>

	<script type="text/javascript">
		console.log("load");
		(function immediate_invoke () {
			'use strict'
			var _={};
			_.formatdate = function(format) {
                var o = {
                        "M+" : this.getMonth()+1, //month
                        "d+" : this.getDate(),    //day
                        "h+" : this.getHours(),   //hour
                        "m+" : this.getMinutes(), //minute
                        "s+" : this.getSeconds(), //second
                        "q+" : Math.floor((this.getMonth()+3)/3),  //quarter
                        "S" : this.getMilliseconds() //millisecond
                }, k;

                if(/(y+)/.test(format)) format=format.replace(RegExp.$1, (this.getFullYear()+"").substr(4 - RegExp.$1.length));
                        for(k in o)if(new RegExp("("+ k +")").test(format))
                                format = format.replace(RegExp.$1,
                RegExp.$1.length==1 ? o[k] : ("00"+ o[k]).substr((""+ o[k]).length));
                return format;
        	};
			_.getStack = function getStack(n) {
			var stacks = [];
			  try {
			    throw new Error("Test")
			    
			  } catch (e) {
			    var stack = e.stack.split("\n");
			    for ( var i = 0,j = stack.length;i<j;i++) {
			      var current = stack[i].match(/^(?:\s*at? ?)?(.+?)(?:@| )\(?(.*?):[^\/](\d*):?(\d*)?/)
			      if (current == null) {
			         continue 
			      }
			      var entry = {
			        fn:current[1]||"anonymous",
			        file:current[2]||"unknown",
			        line:~~current[3],
			        column:~~current[4],
			        time:new Date().getTime()
			      }
			      if ("getStack" !== entry.fn)
			        stacks.push(entry);
			    }
			  } finally {
			    return "number"=== typeof n?stacks[n]:stacks;
			  }
			};
			_.getThisName = function getThisName() {
    			return getStack(1).fn;
			};

			_.console = function console (args, fn) { // better logging inside functions
                var thisname=_.getStack(2).fn;
                window.console.debug(thisname+'(', args,')');
                var key,
                	consoleproxy = {},
                	keys = ['log', 'error', 'debug', 'info'],
                	i=keys.length;
                while (i--) {
                        key = keys[ i ];
                        if (typeof window.console[key]=='function'){
                                consoleproxy[key] = function () {
                                        Array.prototype.unshift.call(arguments, '\t'+thisname+'():'+_.formatdate.call(new Date(),'hh:mm:ss,S'))
                                        window.console[key].apply(window.console, arguments);
                                };
                        }
                }
                return consoleproxy;
        	};



var Deferred = function (/* optional */ canceller) {
    this.chain = [];
    this.id = this._nextId();
    this.fired = -1;
    this.paused = 0;
    this.results = [null, null];
    this.canceller = canceller;
    this.silentlyCancelled = false;
    this.chained = false;
};


Deferred.prototype = {
    /** @id Deferred.prototype.repr */
    repr: function () {
        var state;
        if (this.fired == -1) {
            state = 'unfired';
        } else if (this.fired === 0) {
            state = 'success';
        } else {
            state = 'error';
        }
        return 'Deferred(' + this.id + ', ' + state + ')';
    },

    _nextId: function (n/* = 1 */) {
        if (arguments.length === 0) {
            n = 1;
        }
        return function () {
            return n++;
        };
    },

    /** @id Deferred.prototype.cancel */
    cancel: function () {
        if (this.fired == -1) {
            if (this.canceller) {
                this.canceller(this);
            } else {
                this.silentlyCancelled = true;
            }
            if (this.fired == -1) {
                this.errback(new Error(this));
            }
        } else if ((this.fired === 0) && (this.results[0] instanceof Deferred)) {
            this.results[0].cancel();
        }
    },

    _resback: function (res) {
        /***

        The primitive that means either callback or errback

        ***/
        this.fired = ((res instanceof Error) ? 1 : 0);
        this.results[this.fired] = res;
        this._fire();
    },

    _check: function () {
        if (this.fired != -1) {
            if (!this.silentlyCancelled) {
                throw new Error(this);
            }
            this.silentlyCancelled = false;
            return;
        }
    },

    /** @id Deferred.prototype.callback */
    callback: function (res) {
        this._check();
        if (res instanceof Deferred) {
            throw new Error("Deferred instances can only be chained if they are the result of a callback");
        }
        this._resback(res);
    },

    /** @id Deferred.prototype.errback */
    errback: function (res) {
        this._check();
        if (res instanceof self.Deferred) {
            throw new Error("Deferred instances can only be chained if they are the result of a callback");
        }
        if (!(res instanceof Error)) {
            res = new Error(res);
        }
        this._resback(res);
    },

    /** @id Deferred.prototype.addCallbacks */
    addCallbacks: function (cb, eb) {
        if (this.chained) {
            throw new Error("Chained Deferreds can not be re-used");
        }
        this.chain.push([cb, eb]);
        if (this.fired >= 0) {
            this._fire();
        }
        return this;
    },

    _fire: function () {
        /***

        Used internally to exhaust the callback sequence when a result
        is available.

        ***/
        var chain = this.chain;
        var fired = this.fired;
        var res = this.results[fired];
        var self = this;
        var cb = null;
        while (chain.length > 0 && this.paused === 0) {
            // Array
            var pair = chain.shift();
            var f = pair[fired];
            if (f === null) {
                continue;
            }
            try {
                res = f(res);
                fired = ((res instanceof Error) ? 1 : 0);
                if (res instanceof Deferred) {
                    cb = function (res) {
                        self._resback(res);
                        self.paused--;
                        if ((self.paused === 0) && (self.fired >= 0)) {
                            self._fire();
                        }
                    };
                    this.paused++;
                }
            } catch (err) {
                fired = 1;
                if (!(err instanceof Error)) {
                    err = new Error(err);
                }
                res = err;
            }
        }
        this.fired = fired;
        this.results[fired] = res;
        if (cb && this.paused) {
            // this is for "tail recursion" in case the dependent deferred
            // is already fired
            res.addBoth(cb);
            res.chained = true;
        }
    }
};


			var monadConstructorAsync = function monadConstructorAsync () {
				var console=_.console(arguments);
				var deferred = new Deferred();
				if (!(this instanceof Deferred)) {
					console.debug('this', this);
					deferred.callback(this);
				} else {
					console.debug('this else', this);
				}
				return deferred;
			};



			var monadInstance = monadConstructorAsync.apply([10]);
			monadInstance.addCallbacks(function callback (data) {
				var console=_.console(arguments);
				console.log('this');
			});
			/*list
			(function this1 () {
				console.log('this1', this);
				return this;
			})*/
			/*(function this2 () {
				console.log('this2', this);
				return this;
			})
			(function this3 () {
				console.log('this3', this);
				return this;
			})*/
			console.log("load end");
		})()
	</script>
</body>
</html>